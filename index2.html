<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8>
    <title>PlotXYZ</title>
  </head>
  <body>

    <div id="plot"></div>

    <!-- Leaflet -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.2/leaflet.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.2/leaflet.css">

    <!-- Example data extraction -->
    <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
    <script src="extract.js"></script>

    <!-- New library -->
    <script src="plotXYZ.js"></script>

    <!-- Three JS dependencies -->
    <script src="three.js"></script>
    <script src="trackball.js"></script>

    <script>

    // Steps
    // receive an array of objects with keys: lat, lng, val (float)
    // convert lat/lng to points on square
    // get droop
    // create square with values at each point

    runExtraction('data.csv')
    .then((res) => {

      const settings = {
        values: res,
      }

      let plot = new PlotXYZ(settings);
      let matrix = plot.getMatrix(100, 0.05);

      // for confiiguration
      let matrix_width = matrix.length;
      let matrix_height = matrix[0].length;

      console.log(matrix);

      render = () => {
        controls.update();    
        requestAnimationFrame(render);
        renderer.render(scene, camera);
      }

      var width  = 1200,
          height = 600;

      var scene = new THREE.Scene();

      var camera = new THREE.PerspectiveCamera(50, width / height, 1, 1000);
      camera.position.y = -100;
      camera.position.z = 25;

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize(width, height);
      renderer.shadowMapEnabled = true;
      renderer.shadowMapSoft = true;

      var geometry = new THREE.PlaneGeometry(20, 20, matrix_width, matrix_height);

      geometry.computeFaceNormals();
      geometry.computeVertexNormals();

      let flattened = [];
      matrix.forEach((row) => {
        row.forEach((cell) => {
          flattened.push(cell);
        });
      });
      for (var i = 0; i < geometry.vertices.length; i++) {
        if (flattened[i] && flattened[i].properties) {
          geometry.vertices[i] = new THREE.Vector3(1,-1,-1);
          // geometry.vertices[i].z = flattened[i].properties.val;
        }
      }

      var material = new THREE.MeshPhongMaterial({
        color: 0xdddddd, 
        wireframe: true
      });

      var plane = new THREE.Mesh(geometry, material);
      plane.castShadow = true;
      plane.receiveShadow = true;
      scene.add(plane);

      var controls = new THREE.TrackballControls(camera); 

      document.getElementById('plot').appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0x111111));

      var light = new THREE.DirectionalLight(0xffffff, 1);
      light.shadowCameraVisible = true;
      light.position.set(0,300,100);
      scene.add(light);

      render();
      
    }).catch((err) => {
      throw Error(err);
    });

    </script>
  </body>
</html>