<!DOCTYPE html>
<html>

<head>
  <meta charset=utf-8>
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

  <title>PlotXYZ</title>
</head>

<style>
  #map {
    width: 1600px;
    height: 600px
  }
</style>

<body>
  <div id="map"></div>
</body>

<!-- Outside dependencies -->
<!-- Leaflet CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.2/leaflet.js"></script>
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.2/leaflet.css">

<!-- Mapbox CDN -->
<script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.28.0/mapbox-gl.js'></script>
<link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.28.0/mapbox-gl.css' rel='stylesheet' />

<!-- Turf.js -->
<script type="text/javascript" src="https://api.tiles.mapbox.com/mapbox.js/plugins/turf/v3.0.11/turf.min.js"></script>

<!-- Example data extraction -->
<script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
<script src="extract.js"></script>

<!-- New library -->
<script src="hsv2rgb.js"></script>
<script src="plotXYZ.js"></script>

<!-- Three JS dependencies -->
<!-- <script src="three.js"></script> -->

<script>

// global
let plot;

runExtraction('data.csv')
.then((resp) => {

  const settings = {
    values: resp,
  };

  plot = new PlotXYZ(settings);

  mapboxgl.accessToken = 'pk.eyJ1Ijoia3VhbmIiLCJhIjoidXdWUVZ2USJ9.qNKXXP6z9_fKA8qrmpOi6Q';
  var map = new mapboxgl.Map({
    style: 'mapbox://styles/mapbox/light-v9',
    center: [-99.131513, 19.570851],
    zoom: 12,
    pitch: 45,
    bearing: -17.6,
    container: 'map'
  });

  map.on('load', function() {
    map.addLayer({
      'id': '3d-buildings',
      'source': 'composite',
      'source-layer': 'building',
      'filter': ['==', 'extrude', 'true'],
      'type': 'fill-extrusion',
      'minzoom': 15,
      'paint': {
        'fill-extrusion-color': '#aaa',
        'fill-extrusion-height': {
          'type': 'identity',
          'property': 'height'
        },
        'fill-extrusion-base': {
          'type': 'identity',
          'property': 'min_height'
        },
      }
    });
    
    let fragmentedShapes = [];
    let combinedShapes = [];
    let matrix = plot.getMatrix(100, 0.05);

    matrix.forEach((row, row_i) => {
      row.forEach((cell, col_i) => {
        fragmentedShapes.push(cell);
      });
    });

    let reducedShapes = fragmentedShapes.filter((ea) => {
      return ea && ea.properties && ea.properties.val > 0;
    });

    const scaleMax = 5;
    const scaleMin = 0;
    const categories = 20;

    const segmentLength = (5 - 0)/20;
    let segmentIds = {};
    let segmentIdsList = [];
    
    for (var i = 0; i < 20; i++) {
      let segmentId = 0 + (segmentLength * i);
      segmentIds[segmentId] = [];
      segmentIdsList.push(segmentId);
    }

    let threshold = segmentLength/2;
    reducedShapes.forEach((shape) => {
      let selected;
      segmentIdsList.forEach((ea) => {
        if (shape.properties.val > ea - threshold) {
          segmentIds[String(ea)].push(shape);
        }
      });
    });

    // sort keys so that they are incrementing
    reducedShapes = Object.keys(segmentIds).sort((a, b) => {
      a = Number(a);
      b = Number(b);
      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      } else {
        return 0;
      }
    });

    reducedShapes = reducedShapes.filter(function (segment) {
      return segmentIds[String(segment)].length > 0;
    }).map(function (segment) {
      let seg = segmentIds[String(segment)];
      let reducedSegment;
      if (seg.length > 1) {
        reducedSegment = seg.reduce((a, b) => {
          return turf.union(a, b);
        });
      } else {
        reducedSegment = seg[0];
      }
      reducedSegment.properties.val = Number(segment);
      console.log('processed val', JSON.parse(JSON.stringify(reducedSegment)));
      return reducedSegment;
    }).map(function (ea) {
      console.log(ea.properties.val)
      return ea;
    });

    console.log('reducedShapes' , reducedShapes.map((ea) => { 
        return ea.properties.val; 
      })
    );

    reducedShapes.map((multipolygon) => {
      console.log(multipolygon.properties.val)
      return multipolygon.geometry.coordinates.map((points) => {
        return {
          geometry: {
            type: 'Polygon', 
            coordinates: points
          },
          properties: multipolygon.properties,
          type: 'Feature' 
        };
      })
    }).reduce((a, b) => {
      return a.concat(b);
    });

    L.geoJson(reducedShapes).eachLayer((row) => {
      let i = row._leaflet_id;
      cell = row.feature;

      if (cell.properties.val) {
        cell.properties.height = cell.properties.val * 1000;
        cell.properties.base_height = (cell.properties.val - segmentLength) * 1000;
        cell.properties.color = hsv2rgb(cell.properties.val * 20); // out of 100

        let name = `grid_${i}`;
        map.addSource(name, {
          type: 'geojson',
          data: cell
        });

        map.addLayer({
          id: name,
          type: 'fill-extrusion',
          source: name,
          layout: {},
          paint: {
            'fill-extrusion-color': {
              'property': 'color',
              'type': 'identity'
            },
            'fill-extrusion-height': {
              'property': 'height',
              'type': 'identity'
            },
            'fill-extrusion-base': {
              'property': 'base_height',
              'type': 'identity'
            },
            'fill-extrusion-opacity': 1
          }
        });
      }
    });

  });

});

</script>

</html>